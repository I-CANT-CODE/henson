#pragma once

/* THE FOLLOWING HAS BEEN AUTOMATICALLY GENERATED BY THE EGG PARSER GENERATOR.
 * DO NOT EDIT. */

// {%


#include <string>
#include <vector>
#include <map>
#include <set>
#include <tuple>
#include <sstream>

namespace hwl
{

struct PuppetCommand
{
    std::string     name;
    std::string     command;
};

struct Variable
{
    std::string     name;
    std::string     value;      // default value
};

struct Command
{
    void            add_string(std::string s)   { strings.push_back(s);   indices.emplace_back( strings.size() - 1,   false ); }
    void            add_variable(Variable v)    { variables.push_back(v); indices.emplace_back( variables.size() - 1, true  ); }

    std::string     generate(const std::map<std::string,std::string>& varmap) const
    {
        std::string result;
        for (auto& x : indices)
        {
            if (std::get<1>(x))     // variable
            {
                auto var = variables[std::get<0>(x)];
                auto it  = varmap.find(var.name);
                if (it == varmap.end())
                    result += var.value;
                else
                    result += it->second;
            } else                  // string
            {
                result += strings[std::get<0>(x)];
            }
        }
        return result;
    }

    std::vector<std::string>            strings;
    std::vector<Variable>               variables;
    std::vector<std::tuple<int,bool>>   indices;
};

struct Statement
{
                    Statement()                                 = default;      // needed for egg
                    Statement(std::string c): call(c)           {}
                    Statement(std::string c, std::vector<Statement> b):
                        call(c), body(b)                        {}

    bool            uses(std::string n) const
    {
        if (call == n) return true;
        if (call[0] == '*' && call.substr(1) == n) return true;
        for (auto& s : body)
            if (s.uses(n))
                return true;
        return false;
    }

    std::string             call;
    std::vector<Statement>  body;
};

struct ControlFlow
{
    ControlFlow&    operator=(std::string name_)                { name = name_; return *this; }

    void            set_body(std::vector<Statement> body)       { commands = body; }
    void            set_control(std::string c)                  { control = c; }
    bool            uses(std::string n) const                   { for (auto& s : commands) if (s.uses(n)) return true; return false; }

    std::string                 name;
    std::vector<Statement>      commands;
    std::string                 control;
};

struct Script
{
    void add_puppet(PuppetCommand pc)           { puppets.push_back(pc); }
    void add_procs(ControlFlow cf)              { procs.emplace(cf.name, cf); }

    std::vector<PuppetCommand>                  puppets;
    std::map<std::string, ControlFlow>          procs;
};

std::string     indent_to_tokens(std::string txt)
{
    std::istringstream  in(txt);
    std::string         line;
    size_t  cur = 0;
    int     count = 0;
    std::string         out;
    while (std::getline(in, line))
    {
        size_t indent = 0;
        for (; indent < line.size(); ++indent)
            if (!std::isspace(line[indent]))
                break;

        if (indent == line.size())      // skip empty lines
            continue;

        if (indent > cur)
        {
            out += "INDENT\n";
            cur = indent;
            count++;
        } else if (indent < cur)
        {
            out += "DEDENT\n";
            cur = indent;
            count--;
        }
        out += line + '\n';
    }

    for (size_t i = 0; i < count; ++i)
        out += "DEDENT\n";

    return out;
}

}


// %}

#include <string>
#include "parser.hpp"

namespace hwl {

	bool script(parser::state&, Script               &);
	bool puppet(parser::state&, PuppetCommand        &);
	bool cmd_str(parser::state&, std::string          &);
	bool procs(parser::state&, ControlFlow          &);
	bool statements(parser::state&, std::vector<Statement>   &);
	bool statement(parser::state&, Statement                &);
	bool call(parser::state&, Statement                &);
	bool if_stmt(parser::state&, Statement                &);
	bool command(parser::state&, Command             &);
	bool variable(parser::state&, Variable            &);
	bool name(parser::state&, std::string          &);
	bool letter(parser::state&);
	bool number(parser::state&);
	bool comment(parser::state&);
	bool _(parser::state&);
	bool space(parser::state&);
	bool nl(parser::state&);
	bool eof(parser::state&);
	bool indent(parser::state&);
	bool dedent(parser::state&);

	bool script(parser::state& ps, Script               & psVal) {
		ControlFlow           p;
		PuppetCommand         x;

		return parser::memoize(1, psVal, parser::many(
			parser::choice({
				
					parser::sequence({
						parser::bind(x, puppet),
						[&](parser::state& ps) { psVal.add_puppet(x);  return true; }}),
				
					parser::sequence({
						parser::bind(p, procs),
						[&](parser::state& ps) { psVal.add_procs(p);  return true; }}),
				
					parser::sequence({
						_,
						nl})})))(ps);
	}

	bool puppet(parser::state& ps, PuppetCommand        & psVal) {
		std::string           c;
		std::string           n;

		return parser::memoize(2, psVal, 
			parser::sequence({
				parser::bind(n, name),
				_,
				parser::literal('='),
				_,
				parser::bind(c, cmd_str),
				_,
				nl,
				[&](parser::state& ps) { psVal = { n,c };  return true; }}))(ps);
	}

	bool cmd_str(parser::state& ps, std::string          & psVal) {
		return parser::memoize(3, psVal, parser::capture(psVal, parser::memoize_many(4, 
			parser::sequence({
				parser::look_not(
					parser::choice({
						nl,
						parser::literal('#')})),
				parser::any()}))))(ps);
	}

	bool procs(parser::state& ps, ControlFlow          & psVal) {
		std::vector<Statement>    body;
		std::string           c;
		std::string           n;

		return parser::memoize(5, psVal, 
			parser::sequence({
				parser::bind(n, name),
				_,
				parser::literal("while"),
				_,
				parser::bind(c, name),
				_,
				parser::literal(':'),
				_,
				nl,
				indent,
				nl,
				parser::bind(body, statements),
				dedent,
				nl,
				[&](parser::state& ps) { psVal = n; psVal.set_control(c); psVal.set_body(body);  return true; }}))(ps);
	}

	bool statements(parser::state& ps, std::vector<Statement>   & psVal) {
		Statement                 s;

		return parser::memoize(6, psVal, parser::some(
			parser::choice({
				
					parser::sequence({
						parser::bind(s, statement),
						[&](parser::state& ps) { psVal.push_back(s);  return true; }}),
				
					parser::sequence({
						_,
						nl})})))(ps);
	}

	bool statement(parser::state& ps, Statement                & psVal) {
		return parser::memoize(7, psVal, 
			parser::sequence({
				parser::look_not(
					parser::choice({
						indent,
						dedent})),
				_,
				
					parser::choice({
						parser::bind(psVal, call),
						parser::bind(psVal, if_stmt)})}))(ps);
	}

	bool call(parser::state& ps, Statement                & psVal) {
		std::string n;

		return parser::memoize(8, psVal, 
			parser::sequence({
				parser::capture(n, 
					parser::sequence({
						parser::option(parser::literal('*')),
						parser::unbind(name)})),
				_,
				
					parser::choice({
						nl,
						eof}),
				[&](parser::state& ps) { psVal = Statement(n);  return true; }}))(ps);
	}

	bool if_stmt(parser::state& ps, Statement                & psVal) {
		std::vector<Statement>    body;
		std::string           c;

		return parser::memoize(9, psVal, 
			parser::sequence({
				parser::literal("if"),
				_,
				parser::bind(c, name),
				_,
				parser::literal(':'),
				_,
				nl,
				indent,
				nl,
				parser::bind(body, statements),
				dedent,
				nl,
				[&](parser::state& ps) { psVal = Statement(c, body);  return true; }}))(ps);
	}

	bool command(parser::state& ps, Command             & psVal) {
		std::string s;
		Variable             v;

		return parser::memoize(10, psVal, parser::some(
			parser::choice({
				
					parser::sequence({
						parser::capture(s, parser::memoize_some(11, 
							parser::sequence({
								parser::look_not(parser::literal('$')),
								parser::any()}))),
						[&](parser::state& ps) { psVal.add_string(s);    return true; }}),
				
					parser::sequence({
						parser::bind(v, variable),
						[&](parser::state& ps) { psVal.add_variable(v);  return true; }})})))(ps);
	}

	bool variable(parser::state& ps, Variable            & psVal) {
		std::string           n;
		std::string v;

		return parser::memoize(12, psVal, 
			parser::sequence({
				parser::literal('$'),
				parser::bind(n, name),
				parser::option(
					parser::sequence({
						parser::literal('('),
						parser::capture(v, parser::memoize_many(13, 
							parser::sequence({
								parser::look_not(parser::literal(')')),
								parser::any()}))),
						parser::literal(')'),
						[&](parser::state& ps) { psVal.value = v;  return true; }})),
				[&](parser::state& ps) { psVal.name = n;  return true; }}))(ps);
	}

	bool name(parser::state& ps, std::string          & psVal) {
		return parser::memoize(14, psVal, parser::capture(psVal, 
			parser::sequence({
				letter,
				parser::memoize_many(15, 
					parser::choice({
						letter,
						number}))})))(ps);
	}

	bool letter(parser::state& ps) {
		return parser::memoize(16, 
			parser::choice({
				parser::between('a', 'z'),
				parser::between('A', 'Z'),
				parser::literal('_')}))(ps);
	}

	bool number(parser::state& ps) {
		return parser::memoize(17, parser::between('0', '9'))(ps);
	}

	bool comment(parser::state& ps) {
		return parser::memoize(18, 
			parser::sequence({
				parser::literal('#'),
				parser::memoize_many(19, 
					parser::sequence({
						parser::look_not(nl),
						parser::any()}))}))(ps);
	}

	bool _(parser::state& ps) {
		return parser::memoize(20, parser::memoize_many(21, 
			parser::choice({
				space,
				comment})))(ps);
	}

	bool space(parser::state& ps) {
		return parser::memoize(22, 
			parser::choice({
				parser::literal(' '),
				parser::literal('\t')}))(ps);
	}

	bool nl(parser::state& ps) {
		return parser::memoize(23, 
			parser::choice({
				parser::literal("\n\r"),
				parser::literal('\n'),
				parser::literal('\r')}))(ps);
	}

	bool eof(parser::state& ps) {
		return parser::memoize(24, parser::look_not(parser::any()))(ps);
	}

	bool indent(parser::state& ps) {
		return parser::memoize(25, parser::literal("INDENT"))(ps);
	}

	bool dedent(parser::state& ps) {
		return parser::memoize(26, parser::literal("DEDENT"))(ps);
	}

} // namespace hwl

