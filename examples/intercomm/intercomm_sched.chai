var sched = Scheduler()

def world()
{
    var procmap = ProcMap()
    procmap.rank()

    if(procmap.group("producer"))
    {
        var sim = load("sim", "../simple/simulation 250", procmap)
        var snd = load("snd", "../../tools/send consumer t:int data:array", procmap)

        sim.proceed()

        while(sim.running())
        {
            snd.proceed()
            sim.proceed()
        }

        snd.signal_stop()
        snd.proceed()

    }
    else if(procmap.group("consumer"))
    {

        var rcv = load("rcv", "../../tools/receive producer t:int data:array", procmap)
        var ana = load("ana", "../simple/analysis", procmap)

        rcv.proceed()

        while(rcv.running())
        {
            ana.proceed()
            rcv.proceed()
        }

    }
    else
    {
        print("I'm not part of producer or consumer group!!! Error!")
        flush()
    }

    if(procmap.job_rank() == 2)
    {
        return 1.0;
    }
    else
    {
        return;
    }
}

var procs = sched.get_size()

if(sched.is_controller())
{
    var number_trials = 10
    for(var m = 0; m < number_trials; m = m + 1)
    {
        //print("Scheduiling m: " + to_string(m))
        sched.schedule_job(to_string(m), "world()", ["producer" : 0, "consumer" : 0], procs - 1)
    }
    flush()

    var count_coming_in = 0;
    while(sched.control())
    {
        while(!sched.is_stack_empty)
        {
            count_coming_in = count_coming_in + 1
            var next_elem = sched.next_on_stack()
            //print("Response from " + next_elem.first + " is: " + to_string(next_elem.second))
            sched.pop_stack()
            //sched.check_for_complete_jobs()
        }

        if(count_coming_in == number_trials)
        {
            break
        }
    }
    print("Finished loop sending finish signal!")
    flush()

    sched.finish()
}
else
{
    while(sched.is_active()) { sched.listen() }
}
